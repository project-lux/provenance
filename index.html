<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Provenance Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .highlight {
            background-color: #FEF08A;
            transition: background-color 0.3s ease;
        }
        .source-highlight {
            background-color: #86EFAC;
            transition: background-color 0.3s ease;
        }
        .target-highlight {
            background-color: #FEF08A;
            transition: background-color 0.3s ease;
        }
        .active-movement {
            background-color: #EFF6FF;
            border-left: 4px solid #3B82F6;
        }
        .json-input {
            font-family: 'Courier New', Courier, monospace;
            min-height: 300px;
        }
        .provenance-text {
            white-space: pre-wrap;
            font-family: 'Georgia', serif;
            line-height: 1.6;
        }
        .movement-card {
            transition: all 0.2s ease;
        }
        .movement-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .resizer {
            width: 8px;
            background: #E5E7EB;
            cursor: col-resize;
            transition: background 0.2s;
        }
        .resizer:hover {
            background: #3B82F6;
        }
        .timeline-container {
            padding: 20px;
            border-bottom: 1px solid #E5E7EB;
            background-color: #F9FAFB;
            margin-bottom: 2rem;
        }
        .timeline {
            position: relative;
            height: 8px;
            background-color: #E5E7EB;
            border-radius: 4px;
            margin: 30px 0 15px 0;
        }
        .timeline-marker {
            position: absolute;
            top: -25px;
            transform: translateX(-50%);
            font-size: 12px;
            color: #6B7280;
        }
        .timeline-marker::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 20px;
            height: 15px;
            width: 1px;
            background-color: #9CA3AF;
        }
        .timeline-period {
            position: absolute;
            height: 16px;
            top: -4px;
            border-radius: 4px;
            background-color: #BFDBFE;
            transition: all 0.2s ease;
        }
        .timeline-period.active {
            background-color: #3B82F6;
            height: 20px;
            top: -6px;
        }
        .timeline-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #4B5563;
            white-space: nowrap;
        }
        #viewerContainer {
            display: flex;
            flex-direction: column;
        }
        #timelineContainer {
            flex-shrink: 0;
        }
        .content-container {
            flex: 1;
            display: flex;
            min-height: 0;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 flex items-center">
            <i class="fas fa-history mr-3 text-blue-500"></i> Provenance Viewer
        </h1>
        
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <div class="flex items-center mb-4">
                <i class="fas fa-paste text-blue-500 mr-2"></i>
                <h2 class="text-xl font-semibold text-gray-700">Paste Your JSON</h2>
            </div>
            <textarea id="jsonInput" class="json-input w-full p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Paste your JSON here..."></textarea>
            <div class="flex justify-end mt-4">
                <button id="parseBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-6 rounded-lg flex items-center transition-colors">
                    <i class="fas fa-play mr-2"></i> Parse JSON
                </button>
            </div>
        </div>
        
        <div id="viewerContainer" class="hidden bg-white rounded-lg shadow-md overflow-hidden">
            <div class="flex border-b border-gray-200">
                <div class="px-6 py-4 bg-gray-50 text-gray-700 font-medium flex-1">Provenance Text</div>
                <div class="px-6 py-4 bg-gray-50 text-gray-700 font-medium flex-1">Movement Sequence</div>
            </div>
            
            <div id="timelineContainer" class="timeline-container">
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-sm font-medium text-gray-700">Timeline</h3>
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center">
                            <span class="text-xs text-gray-500 mr-2">Periods</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input id="timelineToggle" type="checkbox" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-500"></div>
                            </label>
                            <span class="text-xs text-gray-500 ml-2">Events</span>
                        </div>
                    </div>
                </div>
                <div class="space-y-8">
                    <div>
                        <div class="text-xs text-gray-500 mb-2">Ownership</div>
                        <div id="ownershipTimeline" class="timeline"></div>
                    </div>
                    <div>
                        <div class="text-xs text-gray-500 mb-2">Location</div>
                        <div id="locationTimeline" class="timeline"></div>
                    </div>
                    <div>
                        <div class="text-xs text-gray-500 mb-2">Custody</div>
                        <div id="custodyTimeline" class="timeline"></div>
                    </div>
                </div>
            </div>
            
            <div class="content-container">
                <div id="provenanceText" class="provenance-text overflow-y-auto p-6 flex-1 border-r border-gray-200"></div>
                
                <div class="resizer" id="resizer"></div>
                
                <div id="movementSequence" class="overflow-y-auto p-6 flex-1">
                    <div id="movementList" class="space-y-4"></div>
                </div>
            </div>
        </div>
        
        <div id="errorContainer" class="hidden bg-red-50 border-l-4 border-red-500 p-4 mb-8 rounded">
            <div class="flex">
                <div class="flex-shrink-0">
                    <i class="fas fa-exclamation-circle text-red-500"></i>
                </div>
                <div class="ml-3">
                    <p id="errorMessage" class="text-sm text-red-700"></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const jsonInput = document.getElementById('jsonInput');
            const parseBtn = document.getElementById('parseBtn');
            const viewerContainer = document.getElementById('viewerContainer');
            const provenanceText = document.getElementById('provenanceText');
            const movementList = document.getElementById('movementList');
            const errorContainer = document.getElementById('errorContainer');
            const errorMessage = document.getElementById('errorMessage');
            
            // Sample JSON for demo purposes
            const sampleJSON = `{
    "provenance": "Made by Ki Enthus Susmono, Tegal, Indonesia, 1999; sold to Dr. Walter Angst (1942-2014), Uberlingen, Germany [See Note I], 2002; by descent to Sir Henry Angest (b.1940), London, England, and Perth, Scotland, 2014 [See Note II]; gift to Yale University Art Gallery, New Haven, Conn., 2018.\\r\\n\\r\\nNotes: [I] Dr. Walter Angst (1942-2014) was a primatologist and notable collector of \u2018wayang\u2019 (Indonesian puppets) and wayang-related material. From the 1970s he amassed a collection of more than 20,000 puppets, mostly in full sets. While most were acquired directly from Indonesian puppet masters and local dealers, he also purchased many on the international art market. His entire collection was gifted to the Yale University Art Gallery, along with his collection notes. Research is currently ongoing to confirm Angst\u2019s acquisition of each object. [II] Upon Dr. Angst\u2019s death, while legal title passed to his brother, Sir Henry Angest (b.1940), who resides in the United Kingdom, the collection remained in Germany until its donation to the YUAG.",
    "output": [
        {
            "movements": [
                {
                    "source": "Unknown",
                    "target": {
                        "name": "Ki Enthus Susmono",
                        "location": "Tegal, Indonesia",
                        "birth_date": "Unknown",
                        "death_date": "Unknown",
                        "type": "Person"
                    },
                    "start_time": "1999",
                    "end_time": "1999",
                    "location": "Tegal, Indonesia",
                    "confidence": "Certain",
                    "method": "The artist",
                    "change_in_ownership": true,
                    "change_in_location": true,
                    "change_in_custody": true
                },
                {
                    "source": {
                        "name": "Ki Enthus Susmono",
                        "location": "Tegal, Indonesia",
                        "birth_date": "Unknown",
                        "death_date": "Unknown",
                        "type": "Person"
                    },
                    "target": {
                        "name": "Dr. Walter Angst",
                        "location": "Uberlingen, Germany",
                        "birth_date": "1942",
                        "death_date": "2014",
                        "type": "Collector"
                    },
                    "start_time": "2002",
                    "end_time": "2002",
                    "location": "Uberlingen, Germany",
                    "confidence": "Certain",
                    "method": "sold to",
                    "change_in_ownership": true,
                    "change_in_location": true,
                    "change_in_custody": true
                },
                {
                    "source": {
                        "name": "Dr. Walter Angst",
                        "location": "Uberlingen, Germany",
                        "birth_date": "1942",
                        "death_date": "2014",
                        "type": "Collector"
                    },
                    "target": {
                        "name": "Sir Henry Angest",
                        "location": "London, England, and Perth, Scotland",
                        "birth_date": "1940",
                        "death_date": "Unknown",
                        "type": "Person"
                    },
                    "start_time": "2014",
                    "end_time": "2014",
                    "location": "Uberlingen, Germany",
                    "confidence": "Certain",
                    "method": "by descent to",
                    "change_in_ownership": true,
                    "change_in_location": false,
                    "change_in_custody": false
                },
                {
                    "source": {
                        "name": "Sir Henry Angest",
                        "location": "London, England, and Perth, Scotland",
                        "birth_date": "1940",
                        "death_date": "Unknown",
                        "type": "Person"
                    },
                    "target": {
                        "name": "Yale University Art Gallery",
                        "location": "New Haven, Conn.",
                        "birth_date": "Unknown",
                        "death_date": "Unknown",
                        "type": "Institution"
                    },
                    "start_time": "2018",
                    "end_time": "2018",
                    "location": "New Haven, Conn.",
                    "confidence": "Certain",
                    "method": "given to",
                    "change_in_ownership": true,
                    "change_in_location": true,
                    "change_in_custody": true
                }
            ],
            "model": "google/gemini-2.5-pro-preview-03-25"
        }
    ],
    "object_id": 236219,
    "errors": {},
    "date": "2025-04-29 14:33:29"
}`;
            
            // Insert sample JSON for demo
            jsonInput.value = sampleJSON;
            
            // Parse JSON button click handler
            parseBtn.addEventListener('click', function() {
                try {
                    const jsonData = JSON.parse(jsonInput.value);
                    displayProvenanceData(jsonData);
                    errorContainer.classList.add('hidden');
                    viewerContainer.classList.remove('hidden');
                } catch (e) {
                    errorMessage.textContent = 'Invalid JSON: ' + e.message;
                    errorContainer.classList.remove('hidden');
                    viewerContainer.classList.add('hidden');
                }
            });
            
            // Display provenance data
            function displayProvenanceData(data) {
                // Display provenance text
                provenanceText.innerHTML = data.provenance.replace(/\n/g, '<br>');
                
                // Clear previous movements
                movementList.innerHTML = '';
                
                // Get movements from the first output item
                const movements = data.output[0].movements;
                
                // Create timeline
                createTimeline(movements);
                
                // Create movement cards
                movements.forEach((movement, index) => {
                    const movementCard = document.createElement('div');
                    movementCard.className = 'movement-card bg-white p-4 rounded-lg border border-gray-200 cursor-pointer';
                    movementCard.dataset.index = index;
                    
                    // Find the text to highlight in the provenance text
                    const highlights = findHighlightText(movement, data.provenance);
                    
                    // Store highlight information as JSON
                    movementCard.dataset.highlights = JSON.stringify(highlights);
                    
                    // Handle potentially unknown locations
                    const sourceLocation = typeof movement.source === 'object' && movement.source.location !== 'Unknown' ? 
                        `<p class="text-xs text-gray-500">${movement.source.location}</p>` : '';
                        
                    const targetLocation = movement.target.location !== 'Unknown' ? 
                        `<p class="text-xs text-gray-500">${movement.target.location}</p>` : '';
                    
                    // Create movement card content
                    movementCard.innerHTML = `
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                <span class="inline-block bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full mb-1">${index + 1}</span>
                                <h3 class="font-medium text-gray-800">${movement.method}</h3>
                            </div>
                            <span class="bg-green-100 text-green-800 text-xs px-2 py-1 rounded-full">${movement.confidence}</span>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4 mb-3">
                            <div>
                                <p class="text-xs text-gray-500 uppercase tracking-wider mb-1">Source</p>
                                <p class="text-sm font-medium text-gray-700">${typeof movement.source === 'object' ? movement.source.name : movement.source}</p>
                                ${sourceLocation}
                            </div>
                            <div>
                                <p class="text-xs text-gray-500 uppercase tracking-wider mb-1">Target</p>
                                <p class="text-sm font-medium text-gray-700">${movement.target.name}</p>
                                ${targetLocation}
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <p class="text-xs text-gray-500 uppercase tracking-wider mb-1">Time</p>
                                <p class="text-sm text-gray-700">${movement.start_time} - ${movement.end_time}</p>
                            </div>
                            <div>
                                <p class="text-xs text-gray-500 uppercase tracking-wider mb-1">Location</p>
                                <p class="text-sm text-gray-700">${movement.location !== 'Unknown' ? movement.location : 'Not specified'}</p>
                            </div>
                        </div>
                    `;
                    
                    // Add click handler to highlight text
                    movementCard.addEventListener('click', function() {
                        highlightProvenanceText(this);
                        setActiveMovement(this);
                    });
                    
                    // Add mouseover handler for hover effect
                    movementCard.addEventListener('mouseover', function() {
                        const highlights = JSON.parse(this.dataset.highlights || '{}');
                        temporarilyHighlightText(highlights);
                        
                        // Highlight corresponding timeline period
                        highlightTimeline(this.dataset.index);
                    });
                    
                    // Add mouseout handler to remove temporary highlights
                    movementCard.addEventListener('mouseout', function() {
                        const activeCard = movementList.querySelector('.active-movement');
                        if (activeCard) {
                            highlightProvenanceText(activeCard);
                        } else {
                            removeTemporaryHighlights();
                            
                            // Remove timeline highlights if no card is active
                            const timelinePeriods = document.querySelectorAll('.timeline-period');
                            timelinePeriods.forEach(period => {
                                period.classList.remove('active');
                            });
                        }
                    });
                    
                    movementList.appendChild(movementCard);
                });
                
                // Highlight the first movement by default
                if (movements.length > 0) {
                    const firstMovement = movementList.children[0];
                    highlightProvenanceText(firstMovement);
                    setActiveMovement(firstMovement);
                }
                
                // Add hover interactions for timeline periods
                setTimeout(() => {
                    const timelinePeriods = document.querySelectorAll('.timeline-period');
                    timelinePeriods.forEach(period => {
                        period.addEventListener('mouseover', function() {
                            const index = this.dataset.index;
                            const movementCard = document.querySelector(`.movement-card[data-index="${index}"]`);
                            if (movementCard) {
                                const event = new MouseEvent('mouseover');
                                movementCard.dispatchEvent(event);
                            }
                            this.classList.add('active');
                        });
                        
                        period.addEventListener('mouseout', function() {
                            const index = this.dataset.index;
                            const movementCard = document.querySelector(`.movement-card[data-index="${index}"]`);
                            if (movementCard) {
                                const event = new MouseEvent('mouseout');
                                movementCard.dispatchEvent(event);
                            }
                        });
                    });
                }, 500);
            }
            
            // Create timeline visualization
            function createTimeline(movements) {
                const ownershipTimelineEl = document.getElementById('ownershipTimeline');
                const locationTimelineEl = document.getElementById('locationTimeline');
                const custodyTimelineEl = document.getElementById('custodyTimeline');
                const timelineToggle = document.getElementById('timelineToggle');
                
                // Function to render all timelines
                function renderTimelines() {
                    // Clear all timelines
                    ownershipTimelineEl.innerHTML = '';
                    locationTimelineEl.innerHTML = '';
                    custodyTimelineEl.innerHTML = '';
                    
                    // Extract all valid years
                    let allYears = [];
                    movements.forEach(movement => {
                        if (movement.start_time && movement.start_time !== 'Unknown') {
                            const yearStr = movement.start_time.replace('Before ', '');
                            const year = parseInt(yearStr);
                            if (!isNaN(year)) allYears.push(year);
                        }
                        if (movement.end_time && movement.end_time !== 'Unknown') {
                            const yearStr = movement.end_time.replace('Before ', '');
                            const year = parseInt(yearStr);
                            if (!isNaN(year)) allYears.push(year);
                        }
                    });
                    
                    // Filter and sort years
                    allYears = allYears.sort((a, b) => a - b);
                    
                    if (allYears.length < 2) {
                        const message = '<div class="text-center text-gray-500">Insufficient date information for timeline</div>';
                        ownershipTimelineEl.innerHTML = message;
                        locationTimelineEl.innerHTML = message;
                        custodyTimelineEl.innerHTML = message;
                        return;
                    }
                    
                    // Calculate min/max years with padding
                    const minYear = Math.floor(allYears[0] / 10) * 10;
                    const maxYear = Math.ceil(allYears[allYears.length - 1] / 10) * 10;
                    const timelineRange = maxYear - minYear;
                    
                    // Create decade markers for each timeline
                    [ownershipTimelineEl, locationTimelineEl, custodyTimelineEl].forEach(timeline => {
                        for (let year = minYear; year <= maxYear; year += 10) {
                            const position = ((year - minYear) / timelineRange) * 100;
                            const marker = document.createElement('div');
                            marker.className = 'timeline-marker';
                            marker.textContent = year;
                            marker.style.left = `${position}%`;
                            timeline.appendChild(marker);
                        }
                    });
                    
                    // Render ownership timeline
                    renderTimelineType(ownershipTimelineEl, movements, 'ownership', minYear, timelineRange);
                    // Render location timeline
                    renderTimelineType(locationTimelineEl, movements, 'location', minYear, timelineRange);
                    // Render custody timeline
                    renderTimelineType(custodyTimelineEl, movements, 'custody', minYear, timelineRange);
                }
                
                // Function to render a specific timeline type
                function renderTimelineType(timelineEl, movements, type, minYear, timelineRange) {
                    let currentEntity = null;
                    let currentStartYear = null;
                    let labels = [];
                    
                    // Reset the timeline container height
                    const container = timelineEl.closest('.timeline-container');
                    container.style.height = 'auto';
                    timelineEl.style.marginBottom = '15px';
                    
                    movements.forEach((movement, index) => {
                        // Skip if start or end time is unknown
                        if (movement.start_time === 'Unknown' || movement.end_time === 'Unknown') return;
                        
                        let startYear = parseInt(movement.start_time.replace('Before ', ''));
                        let endYear = parseInt(movement.end_time.replace('Before ', ''));
                        
                        if (isNaN(startYear) || isNaN(endYear)) return;
                        
                        let entity = null;
                        let shouldCreatePeriod = false;
                        
                        switch(type) {
                            case 'ownership':
                                if (movement.change_in_ownership) {
                                    entity = movement.target.name;
                                    shouldCreatePeriod = true;
                                }
                                break;
                            case 'location':
                                if (movement.change_in_location) {
                                    entity = movement.location;
                                    shouldCreatePeriod = true;
                                }
                                break;
                            case 'custody':
                                if (movement.change_in_custody) {
                                    entity = movement.target.name;
                                    shouldCreatePeriod = true;
                                }
                                break;
                        }
                        
                        if (shouldCreatePeriod && entity) {
                            const isEventsView = timelineToggle.checked; // Fixed the logic
                            
                            if (isEventsView) {
                                // For events view, show a single point in time
                                const eventYear = endYear;
                                const position = ((eventYear - minYear) / timelineRange) * 100;
                                
                                const eventMarker = document.createElement('div');
                                eventMarker.className = 'timeline-period';
                                eventMarker.dataset.index = index;
                                eventMarker.style.left = `${position}%`;
                                eventMarker.style.width = '4px';
                                eventMarker.style.height = '16px';
                                eventMarker.style.top = '-4px';
                                eventMarker.style.backgroundColor = getColorForEntity(entity);
                                
                                // Add label
                                const label = document.createElement('div');
                                label.className = 'timeline-label';
                                label.textContent = `${entity} (${eventYear})`;
                                label.style.left = `${position}%`;
                                eventMarker.appendChild(label);
                                
                                timelineEl.appendChild(eventMarker);
                                labels.push({ position, label });
                                
                                // Add hover events
                                addHoverEvents(eventMarker, index);
                            } else {
                                // For periods view, show the full duration
                                // For same-year transactions, add minimal width
                                if (startYear === endYear) endYear += 1;
                                
                                const startPosition = ((startYear - minYear) / timelineRange) * 100;
                                const endPosition = ((endYear - minYear) / timelineRange) * 100;
                                const width = endPosition - startPosition;
                                
                                const period = document.createElement('div');
                                period.className = 'timeline-period';
                                period.dataset.index = index;
                                period.style.left = `${startPosition}%`;
                                period.style.width = `${width}%`;
                                period.style.backgroundColor = getColorForEntity(entity);
                                
                                // Add label
                                const label = document.createElement('div');
                                label.className = 'timeline-label';
                                label.textContent = `${entity} (${startYear}-${endYear})`;
                                label.style.left = `${(startPosition + endPosition) / 2}%`;
                                period.appendChild(label);
                                
                                timelineEl.appendChild(period);
                                labels.push({ position: (startPosition + endPosition) / 2, label });
                                
                                // Add hover events
                                addHoverEvents(period, index);
                            }
                        }
                    });
                    
                    // Adjust overlapping labels
                    adjustOverlappingLabels(labels, timelineEl);
                }
                
                // Function to adjust overlapping labels
                function adjustOverlappingLabels(labels, timelineEl) {
                    // Sort labels by position
                    labels.sort((a, b) => a.position - b.position);
                    
                    // Group overlapping labels
                    const groups = [];
                    let currentGroup = [];
                    
                    labels.forEach((label, index) => {
                        if (currentGroup.length === 0) {
                            currentGroup.push(label);
                        } else {
                            const lastLabel = currentGroup[currentGroup.length - 1];
                            // Check if labels overlap (within 20% of the timeline)
                            if (Math.abs(label.position - lastLabel.position) < 20) {
                                currentGroup.push(label);
                            } else {
                                groups.push(currentGroup);
                                currentGroup = [label];
                            }
                        }
                    });
                    
                    if (currentGroup.length > 0) {
                        groups.push(currentGroup);
                    }
                    
                    // Find the maximum stack height needed
                    let maxStackHeight = 0;
                    groups.forEach(group => {
                        if (group.length > 1) {
                            const stackHeight = group.length * 20; // 20px per label
                            maxStackHeight = Math.max(maxStackHeight, stackHeight);
                        }
                    });
                    
                    // Adjust positions for overlapping labels and update container height
                    if (maxStackHeight > 0) {
                        const container = timelineEl.closest('.timeline-container');
                        const currentHeight = parseInt(getComputedStyle(container).height);
                        const newHeight = currentHeight + maxStackHeight;
                        container.style.height = `${newHeight}px`;
                        
                        // Adjust the timeline height to accommodate labels
                        timelineEl.style.marginBottom = `${maxStackHeight}px`;
                    }
                    
                    // Position the labels
                    groups.forEach(group => {
                        if (group.length > 1) {
                            group.forEach((label, index) => {
                                // Stack labels vertically
                                label.label.style.bottom = `${-20 - (index * 20)}px`;
                            });
                        }
                    });
                }
                
                // Function to generate colors for different entities
                function getColorForEntity(entity) {
                    const colors = [
                        '#BFDBFE', // blue-200
                        '#C7D2FE', // indigo-200
                        '#DDD6FE', // violet-200
                        '#FBCFE8', // pink-200
                        '#FDE68A', // yellow-200
                        '#A7F3D0', // emerald-200
                        '#BAE6FD', // light-blue-200
                        '#E5E7EB'  // gray-200
                    ];
                    
                    // Create a simple hash of the entity name to get a consistent color
                    let hash = 0;
                    for (let i = 0; i < entity.length; i++) {
                        hash = entity.charCodeAt(i) + ((hash << 5) - hash);
                    }
                    return colors[Math.abs(hash) % colors.length];
                }
                
                // Function to add hover events to timeline elements
                function addHoverEvents(element, index) {
                    element.addEventListener('mouseover', function() {
                        const movementCard = document.querySelector(`.movement-card[data-index="${index}"]`);
                        if (movementCard) {
                            const event = new MouseEvent('mouseover');
                            movementCard.dispatchEvent(event);
                        }
                        this.classList.add('active');
                    });
                    
                    element.addEventListener('mouseout', function() {
                        const movementCard = document.querySelector(`.movement-card[data-index="${index}"]`);
                        if (movementCard) {
                            const event = new MouseEvent('mouseout');
                            movementCard.dispatchEvent(event);
                        }
                        this.classList.remove('active');
                    });
                }
                
                // Initial render
                renderTimelines();
                
                // Handle toggle changes
                timelineToggle.addEventListener('change', function() {
                    renderTimelines();
                });
            }
            
            // Find the text to highlight in the provenance text
            function findHighlightText(movement, provenanceText) {
                const provenanceTextLower = provenanceText.toLowerCase();
                
                // Get source and target names
                const sourceName = typeof movement.source === 'object' ? movement.source.name : movement.source;
                const targetName = movement.target.name;
                const method = movement.method;
                
                // Find source in text
                const sourceResult = {
                    start: -1,
                    end: -1,
                    type: 'source'
                };
                
                // Don't filter out entities if just the location is unknown
                if (sourceName && sourceName !== 'Unknown') {
                    const sourceIndex = provenanceTextLower.indexOf(sourceName.toLowerCase());
                    if (sourceIndex !== -1) {
                        sourceResult.start = sourceIndex;
                        sourceResult.end = sourceIndex + sourceName.length;
                    }
                }
                
                // Find target in text
                let searchText = targetName;
                if (method.includes('descent')) {
                    searchText = `by descent to ${targetName}`;
                } else if (method.includes('transferred')) {
                    searchText = `transferred to ${targetName}`;
                } else if (method.includes('sold')) {
                    searchText = `sold to ${targetName}`;
                } else if (method.includes('given')) {
                    searchText = `given to ${targetName}`;
                }
                
                const targetResult = {
                    start: -1,
                    end: -1,
                    type: 'target'
                };
                
                const startIndex = provenanceTextLower.indexOf(searchText.toLowerCase());
                if (startIndex !== -1) {
                    targetResult.start = startIndex;
                    targetResult.end = startIndex + searchText.length;
                } else {
                    // Fallback to just the target name
                    const fallbackIndex = provenanceTextLower.indexOf(targetName.toLowerCase());
                    if (fallbackIndex !== -1) {
                        targetResult.start = fallbackIndex;
                        targetResult.end = fallbackIndex + targetName.length;
                    }
                }
                
                return {
                    source: sourceResult,
                    target: targetResult
                };
            }
            
            // Highlight text in the provenance viewer
            function highlightProvenanceText(movementElement) {
                // Remove all existing highlights
                const textNodes = getTextNodes(provenanceText);
                textNodes.forEach(node => {
                    if (node.parentNode.classList.contains('highlight') || 
                        node.parentNode.classList.contains('source-highlight') ||
                        node.parentNode.classList.contains('target-highlight')) {
                        const parent = node.parentNode;
                        parent.replaceWith(node);
                    }
                });
                
                // Get highlight data
                const highlights = JSON.parse(movementElement.dataset.highlights || '{}');
                
                // Apply source highlight
                if (highlights.source && highlights.source.start >= 0) {
                    applyHighlight(highlights.source.start, highlights.source.end, 'source-highlight');
                }
                
                // Apply target highlight
                if (highlights.target && highlights.target.start >= 0) {
                    applyHighlight(highlights.target.start, highlights.target.end, 'target-highlight');
                }
                
                // Highlight timeline
                highlightTimeline(movementElement.dataset.index);
            }
            
            // Highlight timeline period
            function highlightTimeline(index) {
                // Remove active class from all timeline periods
                const timelinePeriods = document.querySelectorAll('.timeline-period');
                timelinePeriods.forEach(period => {
                    period.classList.remove('active');
                });
                
                // Add active class to selected period
                const activePeriod = document.querySelector(`.timeline-period[data-index="${index}"]`);
                if (activePeriod) {
                    activePeriod.classList.add('active');
                }
            }
            
            // Apply highlight to a specific range with a given class
            function applyHighlight(start, end, highlightClass) {
                if (start >= 0 && end > start) {
                    const textNodes = getTextNodes(provenanceText);
                    let currentPos = 0;
                    
                    for (const node of textNodes) {
                        const nodeLength = node.textContent.length;
                        
                        if (currentPos + nodeLength > start && currentPos < end) {
                            const rangeStart = Math.max(0, start - currentPos);
                            const rangeEnd = Math.min(nodeLength, end - currentPos);
                            
                            if (rangeStart < rangeEnd) {
                                const before = node.textContent.substring(0, rangeStart);
                                const highlighted = node.textContent.substring(rangeStart, rangeEnd);
                                const after = node.textContent.substring(rangeEnd);
                                
                                const replacement = document.createDocumentFragment();
                                
                                if (before) {
                                    replacement.appendChild(document.createTextNode(before));
                                }
                                
                                if (highlighted) {
                                    const highlightSpan = document.createElement('span');
                                    highlightSpan.className = highlightClass;
                                    highlightSpan.textContent = highlighted;
                                    replacement.appendChild(highlightSpan);
                                }
                                
                                if (after) {
                                    replacement.appendChild(document.createTextNode(after));
                                }
                                
                                node.replaceWith(replacement);
                            }
                        }
                        
                        currentPos += nodeLength;
                    }
                }
            }
            
            // Temporary highlight on hover (modified to preserve highlight during hover)
            function temporarilyHighlightText(highlights) {
                // Remove previous temporary highlights first
                removeTemporaryHighlights();
                
                // Apply source highlight
                if (highlights.source && highlights.source.start >= 0) {
                    applyHighlight(highlights.source.start, highlights.source.end, 'source-highlight');
                }
                
                // Apply target highlight
                if (highlights.target && highlights.target.start >= 0) {
                    applyHighlight(highlights.target.start, highlights.target.end, 'target-highlight');
                }
            }
            
            // Remove temporary highlights
            function removeTemporaryHighlights() {
                const textNodes = getTextNodes(provenanceText);
                textNodes.forEach(node => {
                    if (node.parentNode.classList.contains('source-highlight') ||
                        node.parentNode.classList.contains('target-highlight')) {
                        const parent = node.parentNode;
                        parent.replaceWith(node);
                    }
                });
            }
            
            // Set active movement card
            function setActiveMovement(movementElement) {
                // Remove active class from all movement cards
                const allMovementCards = movementList.querySelectorAll('.movement-card');
                allMovementCards.forEach(card => {
                    card.classList.remove('active-movement');
                });
                
                // Add active class to clicked card
                movementElement.classList.add('active-movement');
                
                // Highlight corresponding timeline period
                highlightTimeline(movementElement.dataset.index);
            }
            
            // Helper function to get all text nodes
            function getTextNodes(element) {
                const textNodes = [];
                const walker = document.createTreeWalker(
                    element,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let node;
                while (node = walker.nextNode()) {
                    textNodes.push(node);
                }
                
                return textNodes;
            }
            
            // Resizer functionality
            const resizer = document.getElementById('resizer');
            const leftPanel = document.getElementById('provenanceText');
            const rightPanel = document.getElementById('movementSequence');
            
            resizer.addEventListener('mousedown', function(e) {
                e.preventDefault();
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
            });
            
            function resize(e) {
                const containerWidth = viewerContainer.offsetWidth;
                const newLeftWidth = (e.clientX - viewerContainer.getBoundingClientRect().left) / containerWidth * 100;
                const newRightWidth = 100 - newLeftWidth;
                
                leftPanel.style.width = `${newLeftWidth}%`;
                rightPanel.style.width = `${newRightWidth}%`;
            }
            
            function stopResize() {
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
            }
        });
    </script>
</body>
</html>